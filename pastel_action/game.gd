class_name Game
extends Node

## Scenes
@export var player_scene: PackedScene

## Static References
@export var main_menu: CenterContainer
@export var start_button: Button
@export var exit_game_button: Button
@export var pause_menu: CenterContainer
@export var resume_button: Button
@export var quit_button: Button
@export var game_interface: HBoxContainer
@export var time_label: Label
@export var score_label: Label

## Debug
const launch_running: bool = false
const quit_on_escape: bool = false

## Runtime References
var player: Player

## Variables
enum state {main_menu, paused, playing}
var ui: state = state.main_menu
var time: float = 0.0
var score: float = 0.0


func _ready() -> void:
	Global.activate.connect(_activate)
	
	if launch_running:
		_on_start_button_down()
	else:
		_on_exit_button_down()


func _process(_delta: float) -> void:
	if Input.is_action_just_pressed(&"menu"):
		if quit_on_escape:
			_on_quit_button_down()
		## Pause
		elif ui == state.playing:
			ui = state.paused
			main_menu.visible = false
			pause_menu.visible = true
			game_interface.visible = false
		## Resume
		elif ui == state.paused:
			ui = state.playing
			main_menu.visible = false
			pause_menu.visible = false
			game_interface.visible = true


func _physics_process(delta: float) -> void:
	if ui == state.playing:
		time += delta
		time_label.text = "Time: " + round_digits(time, 2)
		score_label.text = "Score: " + round_digits(score, 0)
		
		## Spawn random sprites to act as a background
		if randf() < 0.5:
			if get_tree().get_nodes_in_group(&"decorations").size() >= 100:
				get_tree().get_nodes_in_group(&"decorations").pick_random().queue_free()
			var sprite: Sprite2D = Sprite2D.new()
			sprite.texture = player.sprite.texture
			sprite.modulate = Color(randf(), randf(), randf())
			sprite.z_index = -1
			sprite.scale = Vector2(randf_range(0.1, 5.0), randf_range(0.1, 5.0))
			add_child(sprite)
			sprite.global_position = player.global_position\
			+ Vector2(randf_range(-64 * 50, 64 * 50), randf_range(-64 * 50, 64 * 50))
			sprite.add_to_group(&"game_nodes")
			sprite.add_to_group(&"decorations")


func _on_start_button_down() -> void:
	ui = state.playing
	main_menu.visible = false
	pause_menu.visible = false
	game_interface.visible = true
	start_game()


func _on_exit_button_down() -> void:
	ui = state.main_menu
	main_menu.visible = true
	pause_menu.visible = false
	game_interface.visible = false
	exit_game()


func _on_resume_button_down() -> void:
	ui = state.playing
	main_menu.visible = false
	pause_menu.visible = false
	game_interface.visible = true


func _on_quit_button_down() -> void:
	get_tree().quit()


func start_game() -> void:
	## Set up game
	time = 0.0
	score = 0
	var scene: Player = player_scene.instantiate()
	add_child(scene)
	player = scene


func exit_game() -> void:
	## Destroy all nodes generated by game
	get_tree().call_group_flags(SceneTree.GROUP_CALL_DEFERRED, &"game_nodes", &"queue_free")


func _activate(value: float) -> void:
	score += value


## Rounds and truncates a float's decimal part to digit amount of digits
func round_digits(num: float, digit: int) -> String:
	var rounded:String = str(round(num * pow(10.0, digit)) / pow(10.0, digit))
	if digit == 0:
		return rounded
	var s:PackedStringArray = rounded.split(".")
	if s.size() > 1:
		if s[1].length() == digit:
			return s[0] + "." + s[1]
		else:
			return s[0] + "." + s[1] + "0".repeat(digit - s[1].length())
	else:
		return s[0] + "." + "0".repeat(digit)
